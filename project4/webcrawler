#!/usr/bin/env python3
import sys
#import html
#import html.parse
#import parseurl

from lxml import html

from html.parser import HTMLParser
from socket import socket, AF_INET, SOCK_STREAM
from urllib.parse import urlparse
PORT = 80
BUFF = 4096
LOGIN_URL = 'http://fring.ccs.neu.edu/accounts/login/?next=/fakebook\n'

####
import pdb
####


class WebCrawler:

    def __init__(self):
        self.cookie=""

    def request(self, host, request):
        # Open socket and send request. Returns decoded response data
        sock = socket(AF_INET, SOCK_STREAM)
        sock.connect((host, PORT))
        sock.send(request.encode('utf-8'))
        return sock.recv(BUFF).rstrip().decode(), sock

    def prep_url(self, url):
        p_url = urlparse(url)
        path = '/' if not p_url.path else p_url.path
        if p_url.query:
            path += '?'+p_url.query
        return path, p_url.netloc

    def GET(self,url):
        path, host = self.prep_url(url)
        request = 'GET {} HTTP/1.1\n'.format(path) + \
        'Host: {}\n'.format(host) + \
        'Connection: keep-alive\n' + \
        'Accept: text/html,application/xhtml+xml\n' + \
        'User-Agent: ChrisEric/1.1\n' + \
        'Referer: http://{}\n'.format(path) + \
        'Accept-Language: en-US\n' + \
        'Cookie:{}\n'.format(self.cookie)

        data, sock = self.request(host, request)
        for line in data.split("\n"):
            print(line)

        while True:
            init_length = len(data)
            data += sock.recv(BUFF).decode()
            if init_length == len(data):
                break

        print("GET: ")
        for line in data.splitlines():
            print(line)
        print("END GET")

        sock.close()
        return data

    def POST(self,url, **kwargs):
        p_url = urlparse(url)
        path = '/' if not p_url.path else p_url.path
        host = p_url.netloc

        msg = "POST {} HTTP/1.1\n".format(path) + \
        "Host: {}\n".format(host) + \
        "Connection: keep-alive\n" + \
        "Content-Length:92\n" + \
        "Cache-Control: max-age=0\n" + \
        "Accept: text/html,application/xhtml+xml\n" + \
        "Origin: http://{}\n".format(host) + \
        "Upgrade-Insecure-Requests: 1\n" + \
        "User-Agent: ChrisEric/1.1\n" + \
        "Referer: http://{}\n".format(LOGIN_URL) + \
        "Accept-Language: en-US\n"  + \
        "Cookie: csrftoken= {}\n".format(self.token) + \
        "X-CSRFToken: {}\n".format(self.token)
        count = 0
        for key,val in kwargs.items():
            if count > 1:
                msg+='&'
            msg += key+'='+val+'\n'
            count+=1

        data, sock = self.request(host, msg)
        print(data)
        sock.close()

    def fb_login(self,user,pwd):
        data = self.GET(LOGIN_URL)
        parse = LoginHtmlParse()
        parse.feed(data)
        parse.close()
        self.token = parse.token
        self.POST(LOGIN_URL,
                  username=user,
                  password=pwd,
                  next='%2Ffakebook%2F',
                  csrfmiddlewaretoken=self.token)

    def crawl(self):
        pass

class LoginHtmlParse(HTMLParser):
    def handle_starttag(self,tag,attrs):
        if tag == 'input':
            for attr in attrs:
                if len(attr) > 1 and attr[1] == 'csrfmiddlewaretoken':
                    for attr2 in attrs:
                        if attr2[0] == 'value':
                            self.token = attr2[1]
                            return

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("username and password required: ./webcrawl <username> <password>")
        sys.exit()

    username = sys.argv[1]
    password = sys.argv[2]

    crawler = WebCrawler()
    crawler.fb_login(username,password)
    crawler.crawl()

    # tree = html.fromstring(data)
    # print(tree)
