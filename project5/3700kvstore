#!/usr/bin/env python
import math
import threading
import sys, socket, select, time, json, random

STATES = ['FOLLOWER','CANDIDATE','LEADER']

class Server:
    def __init__(self,my_id,replicas):
        self.my_id = my_id
        self.replica_ids = replicas
        # Connect to the network. All messages to/from other replicas and clients will
        # occur over this socket
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        self.sock.connect(my_id)
        # control clock
        self.last_timeout_time = time.time()
        # Current state. Default to follower
        self.current_state = STATES[0]

        ##### Election ######
        # Election timeout. Begin election.
        # Raft paper/vid seemed to indicate timeout of 150-300ms was good range to avoid split votes
        # TODO self.election_timeout = random.randrange(150, 300) * 0.001
        self.election_timeout = random.randrange(15, 30) * 0.1 # TODO FOR DEBUG - lets make it 1.5 to 3 seconds
        self.votes_received = []

        ##### Persistent States #####
        # Current term that this node thinks it is (default 0)
        self.current_term = 0
        # Candidate that received this term's vote
        self.voted_for = None
        # log entries - contains collections of command for state machine, term when received
        # 1-indexed.   Format: (term, {MID:{key:value}})
        # this format is tentative, but should work as just data considering we only get and put, no delete and etc.
        self.log = [(1,{1:{None:None}})]

        ##### Volatile States #####
        # highest known log entry committed (default 0)
        self.commit_index = 0
        # index of highest log entry commited in log[]
        self.last_applied = 0
        #

        ##### Volatile Leader States #####
        # index of the next log entry to send to each server (default: leader's last log index + 1)
        self.next_indexes = []
        # index of the highest log entry known replicated on a server for each server (default 0)
        self.match_indexes = []

        # the data to store after commiting
        self.data = {}
        self.leader = 'FFFF'

    def send_message(self, msg_dict, print_msg=None, update_clock=True):
        msg_dict.update({'leader':self.leader})
        self.sock.send(json.dumps(msg_dict))
        if print_msg:
            print(print_msg)
        if update_clock:
            self.kick_clock()

    def kick_clock(self):
        self.last_timeout_time = time.time()
        # TODO self.election_timeout = random.randrange(150, 300) * 0.001
        self.election_timeout = random.randrange(15, 30) * 0.1 # TODO FOR DEBUG - lets make it 1.5 to 3 seconds

    def start(self):
        threading.Thread(target=self.timeout_thread).start()
        while True:
            ready = select.select([self.sock], [], [], 0.1)[0]
            if self.sock in ready:
                msg_raw = self.sock.recv(32768)
                if len(msg_raw) == 0: continue
                self.handle_message(msg_raw)

    def timeout_thread(self):
        while True:
            clock = time.time()
            if clock-self.last_timeout_time > self.election_timeout:
                # Election timeout timed out

                self.current_term += 1
                self.current_state = STATES[1]
                #TODO: thread request_vote_rpc across all other replicas
                self.request_vote_rpc(self.current_term, self.my_id, len(self.log), self.log[-1][0])

    '''
        Rule Set
    '''

    ##### All #####
    '''
    If commit_index > last_applied: increment last_applied, apply
        log[last_applied] to state machine
    If RPC request or response contains term T > current_term:
        set current_term = T, convert to follower
    '''
    ##### Followers #####
    '''
    Respond to RPCs from candidates and leaders
    If election timeout elapses without receiving append_entries
        RPC from current leader or granting vote to candidate:
        convert to candidate
    '''
    ##### Candidates #####
    '''
    On conversion to candidate, start election:
    Increment current_term
    Vote for self
    Reset election timer
    Send request_vote_rpc to all other servers
    If votes received from majority of servers: become leader
    If append_entries RPC received from new leader: convert to
        follower
    If election timeout elapses: start new election
    '''
    ##### Leaders #####
    '''
    Upon election: send initial empty append_entries_rpc
        (heartbeat) to each server; repeat during idle periods to
        prevent election timeouts
    If command received from client: append entry to local log,
        respond after entry applied to state machine
    If last log index >= next_index for a follower: send
        append_entries RPC with log entries starting at next_index
    If successful: update next_index and match_index for
        follower
    If append_entries fails because of log inconsistency:
        decrement next_index and retry
    If there exists an N such that N > commit_index, a majority
        of match_index[i] >= N, and log[N].term == current_term:
        set commit_index = N
    '''


    '''
        Append Entries RPC
    '''
    def append_entries_rpc(self,
                           term, prev_log_idx,
                           prev_log_term, entries, leader_commit, dst='FFFF'):
        message = {'src':self.my_id,'dst':dst,'type':'request_vote_rpc', # TODO fill in src and dst
                   'prev_log_idx':prev_log_idx,
                   'prev_log_term':prev_log_term,
                   'entries':entries, # (additional entries, lets just do one entry at a time for now)
                   'leader_commit':leader_commit}

        self.send_message(message)

    def handle_append_entries_rpc(self,message):
        '''
        1. Reply false if term < current_term
        2. Reply false if log doesn't contain an entry at prev_log_index
        whose term matches prev_log_term
        3. If an existing entry conflicts with a new one (same index
        but different terms), delete the existing entry and all that
        follow it
        4. Append any new entries not already in the log
        5. If leader_commit > commit_index, set commit_index =
        min(leader_commit, index of last new entry)
        '''
        msg_dict = json.loads(message)
        term = msg_dict.get('term')
        dst = msg_dict.get('src')
        leader = msg_dict.get('leader')
        prev_log_idx = msg_dict.get('prev_log_idx')
        prev_log_term = msg_dict.get('prev_log_term')
        entries = msg_dict.get('entries')
        leader_commit = msg_dict.get('leader_commit')

        # TODO make this multiple entries
        new_entry = None
        if len(entries) > 0:
            new_entry = entries[0]
            new_mid = new_entry.get('MID')
            log_mids = [entry[1].keys()[0] for entry in self.log]

        return_msg = {'src':self.my_id,
                      'dst':dst,
                      'term':self.current_term,
                      'success':False}

        if term < self.current_term: #1
            self.send_message(return_msg)
            return
        elif self.log[prev_log_idx][0] != prev_log_term: #2
            self.send_message(return_msg)
            return


        if new_entry and new_mid in log_mids and self.log[log_mids.index(new_mid)][0] != term: #3 - TODO not sure this is what it means
            self.log = self.log[:log_mids.index(new_mid)] #delete entry and all following

        # Update from heartbeat
        self.kick_clock()

        #4
        # TODO handle when multiple entries behind
        self.log.append((term,{new_mid: { new_entry.get(new_mid).keys()[0] : new_entry.get(new_mid).keys()[0] }}))
        self.prev_log_index += 1
        self.prev_log_term = term
        #5
        if leader_commit > self.commit_index:
            self.commit_index = min(leader_commit, self.prev_log_index)
            # TODO commit data here???

        return_msg['success'] = True
        self.send_message(return_msg)


    '''
        Request Vote RPC
    '''

    def request_vote_rpc(self, term, candidate_id, last_log_index, last_log_term, dst='FFFF'):
        # TODO: RequestVote RPCs should be sent in parallel to all other replicas. Is multicast too expensive vs
        # threading request_vote_rpc?
        message = {'src':self.my_id,
                    'dst':dst,
                    'type':'request_vote_rpc',
                    'term':term,
                    'candidate_id':candidate_id,
                    'last_log_index':last_log_index,
                    'last_log_term':last_log_term}
        self.votedFor = self.my_id
        self.send_message(message, '{} requesting vote RPC'.format(self.my_id))

    def handle_request_vote_rpc(self,msg_dict):
        '''
        1. Reply false if term < current_term
        2. If votedFor is null or candidate_id, and candidate's log is at
        least as up-to-date as receiver's log, grant vote
        '''

        term = msg_dict.get('term')
        candidate_id = msg_dict.get('candidate_id')
        last_log_index = msg_dict.get('last_log_index')
        last_log_term = msg_dict.get('last_log_term')
        dst = msg_dict.get('src')

        grant = term >= self.current_term and last_log_index >= len(self.log) and last_log_term >= self.log[-1][0]
        self.vote(grant,dst, candidate_id,term)

    def vote(self, grant, dst, candidate_id,term):
        message = {'src': self.my_id,
                   'dst': dst,
                   'type': 'vote',
                   'term': max(term, self.current_term), # TODO is this how it should be?
                   'voteGranted': grant}
        if grant:
            self.send_message(message,'{} cast vote for {}'.format(self.my_id, candidate_id))
        else:
            self.send_message(message, '{} denied vote to {}'.format(self.my_id, candidate_id))

    def handle_vote(self,msg_dict):
        if msg_dict.get('voteGranted'):
            self.votes_received.append(msg_dict.get('src'))
        if len(self.votes_received) > math.floor(len(self.replica_ids) / 2):
            self.leader = self.my_id
            self.state = STATES[2]
            # TODO: thread append_entries_rpc across all other replicas
            self.append_entries_rpc(self.current_term, len(self.log), self.log[-1][0], [], self.commit_index)



    '''
        CLIENT-RELATED
    '''


    def redirect_put_to_leader(self,msg_dict):
        msg_dict['dst']=self.leader
        self.send_message(msg_dict)

    def handle_put(self,msg_dict):
        print("Put received: "+str(msg_dict))
        if self.leader == self.my_id:
            self.append_entries_rpc(self.current_term, len(self.log), self.log[-1][0], [], self.commit_index)
            # TODO add to log
            # TODO respond with ok or fail
        else:
            self.redirect_put_to_leader(msg_dict)

    def handle_get(self,msg_dict):
        print("Get received: "+str(msg_dict))
        # TODO return from self.data
        # TODO respond with ok or fail
        pass

    '''
        Handler
                '''
    def handle_message(self,message):
        switch_case = {'append_entries_rpc':self.handle_append_entries_rpc,
                        'request_vote_rpc':self.handle_request_vote_rpc,
                        'vote':self.handle_vote,
                        'put':self.handle_put,
                        'get':self.handle_get,}
        msg_dict = json.loads(message)
        #if msg_dict.get('dst') in (self.my_id, 'FFFF'):
        # Handle noop messages. This may be removed from your final implementation
        switch_case[msg_dict.get('type')](msg_dict)



    '''
    MAIN
    '''

def main():
    # Your ID number = sys.argv[1]
    # The ID numbers of all th,""other replicas = sys.argv[2:]
    server = Server(sys.argv[1], sys.argv[2:])
    server.start()

if __name__=="__main__":
    main()
