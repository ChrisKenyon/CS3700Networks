#!/usr/bin/env python
from socket import socket, AF_INET, SOCK_DGRAM
from zlib import decompress, error, crc32
import datetime
import json
import sys
import random
#import select
#import time
UDP_IP = '127.0.0.1'
UDP_PORT = 0
MSG_SIZE = 1500
TIMEOUT = 30
SEQUENCE = random.randrange(4294967295) #random sequence number within the 32-bit range

msg_buff = {} #{ seq #, data }
latest_seq_in_order = 0

def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

def check_buff():
    global latest_seq_in_order
    global msg_buff
    # update the latest received packet in order by finding the first
    for seq in sorted(msg_buff)[1:]:
        if (len(msg_buff[seq])-seq) not in msg_buff:
            break
        else: latest_seq_in_order = seq
    # debug
    log('CHECK BUFF RESULT: '+str(latest_seq_in_order))
    return latest_seq_in_order + len(msg_buff[latest_seq_in_order])

if __name__=='__main__':
    # Set up the socket
    sock = socket(AF_INET, SOCK_DGRAM)
    sock.bind((UDP_IP,UDP_PORT))
    sock.settimeout(TIMEOUT)

    # Get port we bound to
    UDP_PORT = sock.getsockname()[1]
    log("[bound] " + str(UDP_PORT))

    while True:
        result = sock.recvfrom(MSG_SIZE)
        # If nothing is ready, we hit the timeout
        if result:
            (data, addr) = result
        try:
            # the data may not always be compressed as there isn't always a benefit to it
            try:
                data = decompress(data)
            except error:
                log('receiving uncompressed data')
            decoded = json.loads(data)

            # If the CRC fails
            if 'crc' in decoded:
                recv_crc = int(decoded.pop('crc'))
                calc_crc = sum([crc32(str(val)) for key,val in decoded.iteritems()])
                if recv_crc != calc_crc:
                    log("crc mismatch: {} received and {} generated".format(recv_crc,calc_crc))
                    msg = json.dumps({"nack": decoded['sequence']})
                    log("ABOUT TO SEND " + msg)
                    if sock.sendto(msg, addr) < len(msg):
                        log("[error] unable to fully send packet")
                    continue

            if (decoded.get('syn')):
                if decoded.get('ack'):
                    msg_buff[decoded['sequence']] = '1'
                    latest_seq_in_order = decoded['sequence']
                    continue
                msg = json.dumps({"syn":decoded["sequence"],"ack": decoded['sequence']+1})
            # If the EOF flag is set, exit
            elif (decoded.get('eof')):
                log("[completed]")
                sys.exit(0)
            # If there is data, we accept it and print it out
            elif (decoded.get('data')):
                # ignore duplicates
                if decoded['sequence'] in msg_buff:
                    continue

                log("[recv data] " + str(decoded['sequence']) + " (" + str(len(decoded['data'])) + ") ACCEPTED (in-order)")
                sys.stdout.write(decoded['data'])

                msg_buff[decoded['sequence']]=decoded['data']
                # Send back an ack to the sender
                # TODO: implement advertised window
                msg = json.dumps({"ack": decoded['sequence'] + len(decoded['data']), "sequence": SEQUENCE})
            log("ABOUT TO SEND " + msg)
            if sock.sendto(msg, addr) < len(msg):
                log("[error] unable to fully send packet")

        except (ValueError, KeyError, TypeError) as e:
            log("[recv corrupt packet]")
            raise e
    else:
        log("[error] timeout")
        sys.exit(-1)
