#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
import json
import select
import socket
import sys
import time
import threading

# BPDU format:
#
# {"source": <bridge ID>, "dest": <ID or 'ffff'>, "type": <bpdu or data>, "message": <message data>}
# {"source":"02a1", "dest":"ffff", "type": "bpdu", "message":{"id":"02a1", "root":"02a1", "cost":0}}


class Bridge:

    def __init__(self, bridge_id, LANs):
        # only needs to be in the initialization of the bridge
        # creates sockets and connects to them
        def build_socket(lan):
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            padded_lan = '\0' + lan
            while len(padded_lan) < 108:
                padded_lan += '\0'
            s.connect(padded_lan)
            return s

        self.last_received = {}
        self.bridge_id = bridge_id
        self.root_id = bridge_id
        self.cost_to_root = 0
        # I think the socket file descriptor can be used as the port
        self.lans = {sock.fileno():sock for sock in map(build_socket,LANs)}
        self.enabled = {port : True for port in self.lans}
        self.forwarding = {}
        print("Bridge " + id + " starting up\n")

    def broadcast(self, msg, port_to_exclude=None):
        for port, sock in self.lans.iteritems():
            if self.enabled[port] or port == port_to_exclude:
                sock.send(msg)

    def broadcast_task(self):
        while True:
            bpdu = Bridge.BPDU(self.bridge_id, self.root_id, self.cost_to_root)
            print("Broadcasting: {}/{}".format(self.root_id, self.cost_to_root))
            self.broadcast(str(bpdu))
            # TODO use better time system like a timer class
            time.sleep(1)

    def handle_data(self, port, data):
        # TODO drop packets for now
        # source = data['message']['source']  cast
        # dest = data['message']['dest']
        # self.forwarding[source] = port
        # if dest not in self.forwarding:
        #     self.broadcast(data, port)
        # else:
        #     send port at self.forwarding[dest]
        pass

    def handle_bpdu(self, port, data):
        if data['source'] == self.bridge_id:
            print('Uhh fix this?')
            return
        self.last_received[data.get("source")] = time.time()
        b_root_id = data['message']['root']
        b_root_val = int(b_root_id,16)
        b_bridge_val = int(data['message']['id'],16)
        b_cost = int(data['message']['cost'])
        root_val = int(self.root_id,16)

        # check if it contains better route path
        if (b_root_val < root_val and
            (b_cost + 1 <= self.cost_to_root or
             b_cost == self.cost_to_root == 0)):

            print("Updating to {}/{}".format(b_root_id, b_cost+1))
            self.root_id = b_root_id
            self.cost_to_root = b_cost + 1
            #TODO reenable all?
        # disable port
        #TODO this is wrong I think. It's not removing cycles
        elif (b_root_val == root_val and b_cost == self.cost_to_root and b_bridge_val < root_val):
            print('Disabling port {}'.format(port))
            self.enable[port] = False

    def receive(self):
        # Calls select with all the sockets; change the timeout value (1)
        ready, ignore, ignore2 = select.select(self.lans.values(), [], [], 1)
        # Reads from each fo the ready sockets
        for sock in ready:
            data = sock.recv(1500)
            data = json.loads(data)
            if data["type"] == "data":
                self.handle_data(sock.fileno(), data)
            else:
                print(data)
                self.handle_bpdu(sock.fileno(), data)

    def start(self):
        try:
            threading.Thread(target=self.broadcast_task).start()
            while True:
                self.receive()
        except:
            print(sys.exc_info())

    # A BPDU class to keep the information about this bridge message
    class BPDU:
        def __init__(self, bridge_id, root_id, cost_to_root, dest='ffff'):
            self.bridge_id = bridge_id
            self.dest = dest
            self.root_id = root_id
            self.cost_to_root = cost_to_root
        def __str__(self):
            msg = {
                "source": self.bridge_id,
                "dest": self.dest,
                "type": "bpdu",
                "message": {
                    "id": self.bridge_id,
                    "root": self.root_id,
                    "cost": self.cost_to_root
                }
            }
            return json.dumps(msg)

if __name__ == "__main__":
    id = sys.argv[1]
    LAN = sys.argv[2:]
    bridge = Bridge(id, LAN)
    bridge.start()
